Problem inf-I-06-0: asm-x86/avx/intro-64 (6.0.S)
---
Реализуйте на языке ассемблера x86-64 функцию с сигнатурой:
```
extern double very_important_function(size_t N, const float *A, const float *B, float *R);
```
Функция вычисляет:
1. поэлементную сумму R[i]=A[i]+B[i];
2. среднее арифметическое всех значений R[i], которое является возвращаемым результатом функции.

Гарантируется, что число N больше нуля и кратно 8, а адреса массивов выровнены в памяти по границе 32 байта. Используйте векторные инструкции для вычисления.

Problem inf-I-06-1: asm-x86/avx/sin-64 (6.1.S)
---
Реализуйте на языке ассемблера x86-64 функцию с сигнатурой:
```
extern double avx_sin(double x)
```
которая вычисляет значение sin(x).

Используйте набор команд AVX, а не SSE.

Запрещено использовать встроенные тригонометрические инструкции.

Для вычислений используйте известный вам из курса Математического анализа способ разложения функции в ряд. Точность результата должна быть маскимально возможной для типа данных double. 

Problem inf-I-06-2: asm-x86/avx/dot-product-64 (6.2.S)
---
Реализуйте на языке ассемблера x86-64 функцию с сигнатурой:
```
extern float dot_product(size_t N, const float *A, const float *B);
```
которая вычисляет скалярное произведение векторов A и B.

Гарантируется, что N больше нуля, но не гарантируется, что N кратно восьми.

Значения исходных векторов хранятся в произвольных адресах памяти, поэтому выравнивание для них не гарантируется.

Необходимо минимизировать количество выполняемых вычислительных инструкций, используя векторные вычисления. Доступен набор команд AVX.
